<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ejercicios Interactivos - Arquitecturas CNN</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tensorflow@2.8.0/tf.min.js"></script>
    <style>

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            flex: 1;
            min-width: 300px;
        }
        .exercise-container {
            margin-bottom: 40px;
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }
        .exercise-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .difficulty {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
        }
        .beginner {
            background-color: #d4edda;
            color: #155724;
        }
        .intermediate {
            background-color: #fff3cd;
            color: #856404;
        }
        .advanced {
            background-color: #f8d7da;
            color: #721c24;
        }
        .exercise-content {
            margin-bottom: 20px;
        }
        .exercise-interaction {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        .option {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .option:hover {
            background-color: #f0f0f0;
        }
        .option.selected {
            border-color: #3498db;
            background-color: #ebf5fb;
        }
        .option.correct {
            border-color: #28a745;
            background-color: #d4edda;
        }
        .option.incorrect {
            border-color: #dc3545;
            background-color: #f8d7da;
        }
        .code-block {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            overflow-x: auto;
            margin-bottom: 15px;
        }
        .code-input {
            width: 100%;
            height: 150px;
            font-family: monospace;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .drag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .drag-item {
            padding: 8px 12px;
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: move;
            user-select: none;
        }
        .drop-zone {
            min-height: 100px;
            border: 2px dashed #ced4da;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-content: flex-start;
        }
        .drop-zone.active {
            border-color: #3498db;
            background-color: #ebf5fb;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .feedback.correct {
            display: block;
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .feedback.incorrect {
            display: block;
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .progress-container {
            margin-bottom: 20px;
        }
        .progress-bar {
            height: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .progress-fill {
            height: 100%;
            background-color: #3498db;
            border-radius: 5px;
            width: 0%;
            transition: width 0.5s;
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background-color: #eee;
            border: none;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        .tab.active {
            background-color: #3498db;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .canvas-container {
            width: 100%;
            height: 300px;
            margin-bottom: 20px;
        }
        .hint-button {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 10px;
        }
        .hint {
            background-color: #e2f0fb;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
        }
        .hint.visible {
            display: block;
        }
        .result-summary {
            text-align: center;
            margin: 20px 0;
        }
        .score {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin: 10px 0;
        }
        .certificate {
            border: 2px solid #3498db;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
            background-color: #f8f9fa;
            display: none;
        }
        .certificate h2 {
            color: #3498db;
        }



    </style>
</head>

<body>
        <h1>Interactive Exercises - CNN Architectures</h1>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div>Progress: <span id="progress-text">0%</span></div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="openTab(event, 'quiz')">Quizzes</button>
            <button class="tab" onclick="openTab(event, 'coding')">Coding Exercises</button>
            <button class="tab" onclick="openTab(event, 'architecture')">Architecture Design</button>
        </div>
        
        <div id="quiz" class="tab-content active">
            <div class="exercise-container">
                <div class="exercise-header">
                    <h2>Exercise 1: Convolution Fundamentals</h2>
                    <span class="difficulty beginner">Beginner</span>
                </div>
                
                <div class="exercise-content">
                    <p>Consider a 3x3 convolution filter applied to a 5x5 input image with padding='valid' and stride=1. What will be the spatial dimension of the output?</p>
                    
                    <div class="exercise-interaction">
                        <div class="options-grid">
                            <div class="option" onclick="selectOption('ex1', this, 0)">5x5</div>
                            <div class="option" onclick="selectOption('ex1', this, 1)">3x3</div>
                            <div class="option" onclick="selectOption('ex1', this, 2)">4x4</div>
                            <div class="option" onclick="selectOption('ex1', this, 3)">3x3x3</div>
                        </div>
                        
                        <button onclick="checkAnswer('ex1', 2)">Check</button>
                        <button class="hint-button" onclick="showHint('hint-ex1')">Hint</button>
                        
                        <div class="hint" id="hint-ex1">
                            Remember the formula to calculate the output size with padding='valid': 
                            <br>output_size = (input_size - filter_size) / stride + 1
                        </div>
                        
                        <div class="feedback" id="feedback-ex1"></div>
                    </div>
                </div>
            </div>
 
        <div class="exercise-container">
            <div class="exercise-header">
                <h2>Exercise 2: Classic Architectures</h2>
                <span class="difficulty beginner">Beginner</span>
            </div>
            
            <div class="exercise-content">
                <p>Match each CNN architecture with its main feature:</p>
                
                <div class="exercise-interaction">
                    <div class="drag-container" id="drag-container-ex2">
                        <div class="drag-item" draggable="true" data-id="alexnet">AlexNet</div>
                        <div class="drag-item" draggable="true" data-id="vgg">VGG</div>
                        <div class="drag-item" draggable="true" data-id="inception">GoogLeNet/Inception</div>
                        <div class="drag-item" draggable="true" data-id="resnet">ResNet</div>
                    </div>
                    
                    <div>
                        <p><strong>Architecture with residual connections:</strong></p>
                        <div class="drop-zone" data-expect="resnet" id="drop-resnet"></div>
                        
                        <p><strong>Architecture with inception modules:</strong></p>
                        <div class="drop-zone" data-expect="inception" id="drop-inception"></div>
                        
                        <p><strong>Architecture with a simple and deep design:</strong></p>
                        <div class="drop-zone" data-expect="vgg" id="drop-vgg"></div>
                        
                        <p><strong>First successful deep CNN architecture:</strong></p>
                        <div class="drop-zone" data-expect="alexnet" id="drop-alexnet"></div>
                    </div>
                    
                    <button onclick="checkDragDrop('ex2')">Check</button>
                    
                    <div class="feedback" id="feedback-ex2"></div>
                </div>
            </div>
        </div>


        <div class="exercise-container">
            <div class="exercise-header">
                <h2>Exercise 3: Efficient Architectures</h2>
                <span class="difficulty intermediate">Intermediate</span>
            </div>
            
            <div class="exercise-content">
                <p>Which of the following statements about MobileNet is FALSE?</p>
                
                <div class="exercise-interaction">
                    <div class="options-grid">
                        <div class="option" onclick="selectOption('ex3', this, 0)">It uses depthwise separable convolutions to reduce parameters</div>
                        <div class="option" onclick="selectOption('ex3', this, 1)">It introduces the width multiplier to adjust the model size</div>
                        <div class="option" onclick="selectOption('ex3', this, 2)">It uses inverted bottleneck blocks in all of its versions</div>
                        <div class="option" onclick="selectOption('ex3', this, 3)">It is optimized for mobile and embedded devices</div>
                    </div>
                    
                    <button onclick="checkAnswer('ex3', 2)">Check</button>
                    <button class="hint-button" onclick="showHint('hint-ex3')">Hint</button>
                    
                    <div class="hint" id="hint-ex3">
                        Think about the differences between MobileNetV1 and MobileNetV2, and what innovations each version introduced.
                    </div>
                    
                    <div class="feedback" id="feedback-ex3"></div>
                </div>
            </div>
        </div>

        <div class="exercise-container">
            <div class="exercise-header">
                <h2>Exercise 4: Architectures for Segmentation</h2>
                <span class="difficulty intermediate">Intermediate</span>
            </div>
            
            <div class="exercise-content">
                <p>Select all features that are specific to the U-Net architecture:</p>
                
                <div class="exercise-interaction">
                    <div class="options-grid">
                        <div class="option" onclick="toggleMultiOption('ex4', this, 0)">Symmetric encoder-decoder architecture</div>
                        <div class="option" onclick="toggleMultiOption('ex4', this, 1)">Skip connections between corresponding levels</div>
                        <div class="option" onclick="toggleMultiOption('ex4', this, 2)">Residual blocks at each level</div>
                        <div class="option" onclick="toggleMultiOption('ex4', this, 3)">Originally designed for medical image segmentation</div>
                        <div class="option" onclick="toggleMultiOption('ex4', this, 4)">Uses spatial attention at each level</div>
                    </div>
                    
                    <button onclick="checkMultiAnswer('ex4', [0, 1, 3])">Check</button>
                    <button class="hint-button" onclick="showHint('hint-ex4')">Hint</button>
                    
                    <div class="hint" id="hint-ex4">
                        U-Net has a characteristic "U" shape due to its design. Think about its original components before considering later variants.
                    </div>
                    
                    <div class="feedback" id="feedback-ex4"></div>
                </div>
            </div>
        </div>

        <div class="exercise-container">
            <div class="exercise-header">
                <h2>Exercise 5: Architectures for Detection</h2>
                <span class="difficulty advanced">Advanced</span>
            </div>
            
            <div class="exercise-content">
                <p>Chronologically order the following object detection architectures based on their appearance:</p>
                
                <div class="exercise-interaction">
                    <div class="drag-container" id="drag-container-ex5">
                        <div class="drag-item" draggable="true" data-id="yolov3">YOLO v3</div>
                        <div class="drag-item" draggable="true" data-id="rcnn">R-CNN</div>
                        <div class="drag-item" draggable="true" data-id="fasterrcnn">Faster R-CNN</div>
                        <div class="drag-item" draggable="true" data-id="yolov1">YOLO v1</div>
                    </div>
                    
                    <div>
                        <p><strong>Chronological order (oldest on top):</strong></p>
                        <div class="drop-zone" data-position="0" id="drop-pos0"></div>
                        <div class="drop-zone" data-position="1" id="drop-pos1"></div>
                        <div class="drop-zone" data-position="2" id="drop-pos2"></div>
                        <div class="drop-zone" data-position="3" id="drop-pos3"></div>
                    </div>
                    
                    <button onclick="checkOrderDragDrop('ex5', ['rcnn', 'fasterrcnn', 'yolov1', 'yolov3'])">Check</button>
                    <button class="hint-button" onclick="showHint('hint-ex5')">Hint</button>
                    
                    <div class="hint" id="hint-ex5">
                        R-CNN was one of the first successful CNN-based detectors, while YOLO introduced the single-stage detection paradigm after Faster R-CNN.
                    </div>
                    
                    <div class="feedback" id="feedback-ex5"></div>
                </div>
            </div>
        </div>        

        </div>

        <div id="coding" class="tab-content">

            <div class="exercise-container">
                <div class="exercise-header">
                    <h2>Exercise 1: Convolution Implementation</h2>
                    <span class="difficulty intermediate">Intermediate</span>
                </div>
            
                <div class="exercise-content">
                    <p>Complete the following code to implement a 3x3 convolutional layer with 16 filters, stride=1 and 'same' padding using PyTorch:</p>
            
                    <div class="code-block">
            <pre><code class="language-python">
            import torch
            import torch.nn as nn
            
            class SimpleCNN(nn.Module):
                def __init__(self):
                    super(SimpleCNN, self).__init__()
                    self.conv = nn.______(______, kernel_size=______, stride=______, padding=______)
                    self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
                    self.flatten = nn.Flatten()
                    self.fc = nn.Linear(16 * 14 * 14, 10)  # Assuming input is 28x28
            
                def forward(self, x):
                    x = torch.relu(self.conv(x))
                    x = self.pool(x)
                    x = self.flatten(x)
                    x = self.fc(x)
                    return x
            </code></pre>
                    </div>
            
                    <div class="exercise-interaction">
                        <textarea class="code-input" id="code-ex1">self.conv = nn.</textarea>
            
                        <button onclick="checkCode('ex1', 'Conv2d(1, 16, kernel_size=3, stride=1, padding=1)')">Check</button>
                        <button class="hint-button" onclick="showHint('hint-code-ex1')">Hint</button>
            
                        <div class="hint" id="hint-code-ex1">
                            In PyTorch, the convolutional layer is called <code>nn.Conv2d</code>. Use <code>padding=1</code> with a 3x3 kernel and stride 1 to simulate 'same' padding.
                        </div>
            
                        <div class="feedback" id="feedback-code-ex1"></div>
                    </div>
                </div>
            </div>
        

            <div class="exercise-container">
                <div class="exercise-header">
                    <h2>Exercise 2: Residual Block</h2>
                    <span class="difficulty advanced">Advanced</span>
                </div>
            
                <div class="exercise-content">
                    <p>Implement a basic residual block like the one used in ResNet. The block should contain two 3x3 convolutional layers with the same number of filters and a skip connection:</p>
            
                    <div class="code-block">
                    <pre><code class="language-python">
                    import torch
                    import torch.nn as nn
                    import torch.nn.functional as F
                    
                    class ResidualBlock(nn.Module):
                        def __init__(self, channels):
                            super(ResidualBlock, self).__init__()
                            self.conv1 = nn.Conv2d(channels, channels, kernel_size=3, padding=1)
                            self.bn1 = nn.BatchNorm2d(channels)
                            self.conv2 = nn.Conv2d(channels, channels, kernel_size=3, padding=1)
                            self.bn2 = nn.BatchNorm2d(channels)
                    
                        def forward(self, x):
                            # Store input for the skip connection
                            shortcut = x
                    
                            # First convolutional layer
                    
                            # Second convolutional layer
                    
                            # Add skip connection
                    
                            return y
                    </code></pre>
                    </div>
            
                    <div class="exercise-interaction">
                        <textarea class="code-input" id="code-ex2">
        # Store input for the skip connection
        shortcut = x
        # First conv layer  
        # Second conv layer  
        # Skip connection  
        # ReLU  
                        </textarea>
            
                        <button onclick="checkResidualBlock('ex2')">Check</button>
                        <button class="hint-button" onclick="showHint('hint-code-ex2')">Hint</button>
            
                        <div class="hint" id="hint-code-ex2">
                            A basic residual block has this structure: Conv → BN → ReLU → Conv → BN → Add(input) → ReLU.
                        </div>
            
                        <div class="feedback" id="feedback-code-ex2"></div>
                    </div>
                </div>
            </div>

            <div class="exercise-container">
                <div class="exercise-header">
                    <h2>Exercise 3: Depthwise Separable Convolution</h2>
                    <span class="difficulty advanced">Advanced</span>
                </div>
            
                <div class="exercise-content">
                    <p>Complete the following code to implement a depthwise separable convolution block like the one used in MobileNet:</p>
            
                    <div class="code-block">
                        <pre><code class="language-python">
                        import torch
                        import torch.nn as nn
                        import torch.nn.functional as F
                        
                        class DepthwiseSeparableConv(nn.Module):
                            def __init__(self, in_channels, out_channels, kernel_size=3):
                                super(DepthwiseSeparableConv, self).__init__()
                                # Depthwise convolution
                                self.depthwise = nn.___(___, ___, ___, ___, ___)
                                # Pointwise convolution
                                self.pointwise = nn.___(___, ___, ___)
                        
                            def forward(self, x):
                                x = F.relu(self.depthwise(x))
                                x = F.relu(self.pointwise(x))
                                return x
                        </code></pre>
                    </div>
            
                    <div class="exercise-interaction">
                        <textarea class="code-input" id="code-ex3">
        # Depthwise convolution
        self.depthwise = nn.___(___, ___, ___, ___, ___)
        # Pointwise convolution
        self.pointwise = nn.___(___, ___, ___)
                        </textarea>
            
                        <button onclick="checkDepthwiseSeparableConv('ex3')">Check</button>
                        <button class="hint-button" onclick="showHint('hint-code-ex3')">Hint</button>
            
                        <div class="hint" id="hint-code-ex3">
                            A depthwise separable convolution consists of two steps:  
                            1. <code>nn.Conv2d</code> with <code>groups=in_channels</code> (depthwise)  
                            2. <code>nn.Conv2d</code> with <code>kernel_size=1</code> (pointwise)  
                            This is used to reduce parameters while maintaining performance.
                        </div>
            
                        <div class="feedback" id="feedback-code-ex3"></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="architecture" class="tab-content">
            <div class="exercise-container">
                <div class="exercise-header">
                    <h2>Exercise 1: CNN Design for Classification</h2>
                    <span class="difficulty intermediate">Intermediate</span>
                </div>
                
                <div class="exercise-content">
                    <p>Design a CNN for CIFAR-10 image classification (32x32x3) by dragging and ordering the layers:</p>
                    
                    <div class="exercise-interaction">
                        <div class="drag-container" id="drag-container-arch1">
                            <div class="drag-item" draggable="true" data-id="input">Input(32,32,3)</div>
                            <div class="drag-item" draggable="true" data-id="conv1">Conv2D(32,3,3)</div>
                            <div class="drag-item" draggable="true" data-id="conv2">Conv2D(64,3,3)</div>
                            <div class="drag-item" draggable="true" data-id="conv3">Conv2D(128,3,3)</div>
                            <div class="drag-item" draggable="true" data-id="pool1">MaxPooling2D(2,2)</div>
                            <div class="drag-item" draggable="true" data-id="pool2">MaxPooling2D(2,2)</div>
                            <div class="drag-item" draggable="true" data-id="dropout1">Dropout(0.25)</div>
                            <div class="drag-item" draggable="true" data-id="dropout2">Dropout(0.5)</div>
                            <div class="drag-item" draggable="true" data-id="flatten">Flatten()</div>
                            <div class="drag-item" draggable="true" data-id="dense1">Dense(512)</div>
                            <div class="drag-item" draggable="true" data-id="dense2">Dense(10, softmax)</div>
                        </div>
                        
                        <p><strong>CNN Architecture (order top to bottom):</strong></p>
                        <div class="drop-zone" id="architecture-drop-zone" style="min-height: 300px;"></div>
                        
                        <button onclick="evaluateArchitecture('arch1')">Evaluate Architecture</button>
                        <button class="hint-button" onclick="showHint('hint-arch1')">Hint</button>
                        
                        <div class="hint" id="hint-arch1">
                            A typical CNN architecture follows this pattern: input layer → convolutional blocks (Conv+Pool) → flatten → dense layers → output layer. Consider where to place dropout to prevent overfitting.
                        </div>
                        
                        <div class="feedback" id="feedback-arch1"></div>
                    </div>
                </div>
            </div>
            
            <div class="exercise-container">
                <div class="exercise-header">
                    <h2>Exercise 2: Architecture Analysis</h2>
                    <span class="difficulty advanced">Advanced</span>
                </div>
                
                <div class="exercise-content">
                    <p>Analyze the following architectures and choose the most suitable one for each use case:</p>
                    
                    <div class="exercise-interaction">
                        <p><strong>1. Real-time object detection on a mobile device:</strong></p>
                        <div class="options-grid">
                            <div class="option" onclick="selectOption('arch-use1', this, 0)">VGG16</div>
                            <div class="option" onclick="selectOption('arch-use1', this, 1)">YOLO</div>
                            <div class="option" onclick="selectOption('arch-use1', this, 2)">U-Net</div>
                            <div class="option" onclick="selectOption('arch-use1', this, 3)">ResNet-152</div>
                        </div>
                        
                        <p><strong>2. Accurate tumor segmentation in medical images:</strong></p>
                        <div class="options-grid">
                            <div class="option" onclick="selectOption('arch-use2', this, 0)">MobileNet</div>
                            <div class="option" onclick="selectOption('arch-use2', this, 1)">AlexNet</div>
                            <div class="option" onclick="selectOption('arch-use2', this, 2)">U-Net</div>
                            <div class="option" onclick="selectOption('arch-use2', this, 3)">YOLO</div>
                        </div>
                        
                        <p><strong>3. High-accuracy image classification without resource constraints:</strong></p>
                        <div class="options-grid">
                            <div class="option" onclick="selectOption('arch-use3', this, 0)">ResNet-50</div>
                            <div class="option" onclick="selectOption('arch-use3', this, 1)">LeNet-5</div>
                            <div class="option" onclick="selectOption('arch-use3', this, 2)">MobileNetV2</div>
                            <div class="option" onclick="selectOption('arch-use3', this, 3)">SqueezeNet</div>
                        </div>
                        
                        <button onclick="checkArchitectureUseCase()">Check</button>
                        
                        <div class="feedback" id="feedback-arch-use"></div>
                    </div>
                </div>
            </div>
        </div>
    
        
    
    <div class="result-summary" id="result-summary" style="display: none;">
        <h2>Results Summary</h2>
        <p>You have completed all the exercises.</p>
        <div class="score">Score: <span id="final-score">0</span>/<span id="total-score">0</span></div>
        <button onclick="showCertificate()">View Certificate</button>
    </div>
    
    <div class="certificate" id="certificate">
        <h2>Certificate of Completion</h2>
        <h3>Interactive CNN Architecture Course</h3>
        <p>This certificate certifies that</p>
        <h3 id="user-name">Student</h3>
        <p>has successfully completed all interactive exercises of the course.</p>
        <p>Date: <span id="certificate-date"></span></p>
    </div>
        

    <script>
        // Variables globales
        let selectedOptions = {};
        let multiSelectedOptions = {};
        let completedExercises = {};
        let totalExercises = 10; // Actualizar según el número total de ejercicios
        let score = 0;
        
        // Inicialización
        document.addEventListener('DOMContentLoaded', function() {
            initDragAndDrop();
            updateProgress();
        });
        
        // Función para abrir pestaña
        function openTab(evt, tabName) {
            // Ocultar todos los contenidos de pestañas
            let tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            // Desactivar todos los botones de pestañas
            let tabs = document.getElementsByClassName('tab');
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove('active');
            }
            
            // Mostrar el contenido de la pestaña actual y activar el botón
            document.getElementById(tabName).classList.add('active');
            evt.currentTarget.classList.add('active');
        }
        
        // Seleccionar opción en preguntas de opción única
        function selectOption(exerciseId, element, optionIndex) {
            // Deseleccionar otras opciones
            let options = element.parentElement.getElementsByClassName('option');
            for (let i = 0; i < options.length; i++) {
                options[i].classList.remove('selected');
            }
            
            // Seleccionar la opción actual
            element.classList.add('selected');
            
            // Guardar selección
            selectedOptions[exerciseId] = optionIndex;
        }
        
        // Seleccionar/deseleccionar opción en preguntas de opción múltiple
        function toggleMultiOption(exerciseId, element, optionIndex) {
            // Inicializar array si no existe
            if (!multiSelectedOptions[exerciseId]) {
                multiSelectedOptions[exerciseId] = [];
            }
            
            // Toggle selección
            if (element.classList.contains('selected')) {
                element.classList.remove('selected');
                // Eliminar del array
                let index = multiSelectedOptions[exerciseId].indexOf(optionIndex);
                if (index > -1) {
                    multiSelectedOptions[exerciseId].splice(index, 1);
                }
            } else {
                element.classList.add('selected');
                // Añadir al array
                multiSelectedOptions[exerciseId].push(optionIndex);
            }
        }
        
        // Check single-choice answer
        function checkAnswer(exerciseId, correctIndex) {
            let feedbackElement = document.getElementById('feedback-' + exerciseId);

            if (selectedOptions[exerciseId] === undefined) {
                feedbackElement.textContent = 'Please select an option.';
                feedbackElement.className = 'feedback incorrect';
                return;
            }

            if (selectedOptions[exerciseId] === correctIndex) {
                feedbackElement.textContent = 'Correct! You selected the right answer.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete(exerciseId, true);
            } else {
                feedbackElement.textContent = 'Incorrect. Try again.';
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete(exerciseId, false);
            }
        }

        
        // Check multiple-choice answer
        function checkMultiAnswer(exerciseId, correctIndices) {
            let feedbackElement = document.getElementById('feedback-' + exerciseId);

            if (!multiSelectedOptions[exerciseId] || multiSelectedOptions[exerciseId].length === 0) {
                feedbackElement.textContent = 'Please select at least one option.';
                feedbackElement.className = 'feedback incorrect';
                return;
            }

            // Sort arrays for comparison
            let selected = [...multiSelectedOptions[exerciseId]].sort();
            let correct = [...correctIndices].sort();

            // Compare arrays
            let isCorrect = selected.length === correct.length &&
                            selected.every((value, index) => value === correct[index]);

            if (isCorrect) {
                feedbackElement.textContent = 'Correct! You selected all the correct options.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete(exerciseId, true);
            } else {
                feedbackElement.textContent = 'Incorrect. You did not select exactly the correct options.';
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete(exerciseId, false);
            }
        }

        
        // Inicializar funcionalidad de arrastrar y soltar
        function initDragAndDrop() {
            // Obtener todos los elementos arrastrables
            const draggables = document.querySelectorAll('.drag-item');
            const dropZones = document.querySelectorAll('.drop-zone');
            
            // Configurar eventos para elementos arrastrables
            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', draggable.dataset.id);
                    setTimeout(() => {
                        draggable.classList.add('dragging');
                    }, 0);
                });
                
                draggable.addEventListener('dragend', function() {
                    draggable.classList.remove('dragging');
                });
            });
            
            // Configurar eventos para zonas de destino
            dropZones.forEach(dropZone => {
                dropZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    dropZone.classList.add('active');
                });
                
                dropZone.addEventListener('dragleave', function() {
                    dropZone.classList.remove('active');
                });
                
                dropZone.addEventListener('drop', function(e) {
                    e.preventDefault();
                    dropZone.classList.remove('active');
                    
                    const id = e.dataTransfer.getData('text/plain');
                    const draggable = document.querySelector(`.drag-item[data-id="${id}"]`);
                    
                    // Clonar el elemento para mantener el original en el contenedor
                    const clone = draggable.cloneNode(true);
                    clone.classList.add('in-dropzone');
                    
                    // Limpiar zona de destino si es necesario (para zonas que solo aceptan un elemento)
                    if (!dropZone.id.includes('architecture')) {
                        dropZone.innerHTML = '';
                    }
                    
                    dropZone.appendChild(clone);
                    
                    // Hacer que el clon sea arrastrable dentro de la zona de arquitectura
                    if (dropZone.id === 'architecture-drop-zone') {
                        initDraggableInDropZone(clone);
                    }
                });
            });
        }
        
        // Hacer que los elementos en la zona de arquitectura sean arrastrables
        function initDraggableInDropZone(element) {
            element.addEventListener('dragstart', function(e) {
                e.dataTransfer.setData('text/plain', 'move-in-zone');
                setTimeout(() => {
                    element.classList.add('dragging');
                }, 0);
            });
            
            element.addEventListener('dragend', function() {
                element.classList.remove('dragging');
            });
        }
        
        // Check drag-and-drop matching exercise
        function checkDragDrop(exerciseId) {
            let isCorrect = true;
            const dropZones = document.querySelectorAll('.drop-zone[data-expect]');

            dropZones.forEach(zone => {
                const expectedId = zone.dataset.expect;
                const droppedItem = zone.querySelector('.drag-item');

                if (!droppedItem || droppedItem.dataset.id !== expectedId) {
                    isCorrect = false;
                }
            });

            let feedbackElement = document.getElementById('feedback-' + exerciseId);

            if (isCorrect) {
                feedbackElement.textContent = 'Correct! You matched all architectures correctly.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete(exerciseId, true);
            } else {
                feedbackElement.textContent = 'Incorrect. Check the relationships between architectures and their features.';
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete(exerciseId, false);
            }
        }

        
        // Comprobar ejercicio de ordenar arrastrando
        function checkOrderDragDrop(exerciseId, correctOrder) {
            let currentOrder = [];
            
            // Recopilar el orden actual
            for (let i = 0; i < correctOrder.length; i++) {
                const zone = document.getElementById('drop-pos' + i);
                const item = zone.querySelector('.drag-item');
                
                if (item) {
                    currentOrder.push(item.dataset.id);
                } else {
                    currentOrder.push(null);
                }
            }
            
            // Verificar si el orden es correcto
            let isCorrect = true;
            for (let i = 0; i < correctOrder.length; i++) {
                if (currentOrder[i] !== correctOrder[i]) {
                    isCorrect = false;
                    break;
                }
            }
            
            let feedbackElement = document.getElementById('feedback-' + exerciseId);
            if (isCorrect) {
                feedbackElement.textContent = 'Correct! You ordered the architectures correctly.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete(exerciseId, true);
            } else {
                feedbackElement.textContent = 'Incorrect. The chronological order is not correct.';
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete(exerciseId, false);
            }

        }
        
 

        // Check PyTorch Conv2d implementation
        function checkCode(exerciseId, expectedCode) {
            const userCode = document.getElementById('code-' + exerciseId).value.trim();
            const feedbackElement = document.getElementById('feedback-code-' + exerciseId);

            // Normalize user code for comparison
            const normalizedUserCode = userCode
                .replace(/\s+/g, ' ')       // collapse whitespace
                .replace(/'/g, '\'')        // unify single quotes
                .replace(/"/g, '\'')        // unify double quotes
                .toLowerCase();             // case-insensitive match

            const normalizedExpected = expectedCode
                .replace(/\s+/g, ' ')
                .replace(/'/g, '\'')
                .replace(/"/g, '\'')
                .toLowerCase();

            if (normalizedUserCode.includes(normalizedExpected)) {
                feedbackElement.textContent = 'Correct! Your convolutional layer implementation is correct.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete(exerciseId, true);
            } else {
                feedbackElement.textContent = 'Incorrect. Check the parameters of your Conv2d layer.';
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete(exerciseId, false);
            }
        }

        // Check residual block implementation in PyTorch
        function checkResidualBlock(exerciseId) {
            const userCode = document.getElementById('code-' + exerciseId).value.trim();
            let feedbackElement = document.getElementById('feedback-code-' + exerciseId);

            // Look for key components
            const hasShortcut = userCode.includes('shortcut = x');
            const hasFirstConv = userCode.includes('self.conv1') || userCode.includes('conv1');
            const hasSecondConv = userCode.includes('self.conv2') || userCode.includes('conv2');
            const hasBatchNorm = userCode.includes('bn1') || userCode.includes('BatchNorm2d');
            const hasActivation = userCode.includes('F.relu');
            const hasAdd = userCode.includes('+ shortcut') || userCode.includes('shortcut +');

            if (hasShortcut && hasFirstConv && hasSecondConv && hasBatchNorm && hasActivation && hasAdd) {
                feedbackElement.textContent = 'Correct! Your residual block implementation contains all necessary components.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete(exerciseId, true);
            } else {
                let missing = [];
                if (!hasShortcut) missing.push('shortcut connection');
                if (!hasFirstConv) missing.push('first convolutional layer');
                if (!hasSecondConv) missing.push('second convolutional layer');
                if (!hasBatchNorm) missing.push('batch normalization');
                if (!hasActivation) missing.push('activation function (ReLU)');
                if (!hasAdd) missing.push('skip connection addition');

                feedbackElement.textContent = `Incorrect. Your implementation is missing: ${missing.join(', ')}.`;
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete(exerciseId, false);
            }
        }

        // Check depthwise separable convolution implementation in PyTorch
        function checkDepthwiseSeparableConv(exerciseId) {
            const userCode = document.getElementById('code-' + exerciseId).value.trim();
            let feedbackElement = document.getElementById('feedback-code-' + exerciseId);

            // Look for key PyTorch elements
            const hasDepthwise = userCode.includes('nn.Conv2d') &&
                                userCode.includes('groups=') &&
                                (userCode.includes('groups=in_channels') || userCode.includes('groups=in_channels'));

            const hasPointwise = userCode.includes('nn.Conv2d') &&
                                (userCode.includes('kernel_size=1') || userCode.includes('kernel_size=(1, 1)'));

            if (hasDepthwise && hasPointwise) {
                feedbackElement.textContent = 'Correct! Your depthwise separable convolution implementation is correct.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete(exerciseId, true);
            } else {
                let missing = [];
                if (!hasDepthwise) missing.push('depthwise convolution (Conv2d with groups=in_channels)');
                if (!hasPointwise) missing.push('pointwise convolution (Conv2d with kernel_size=1)');

                feedbackElement.textContent = `Incorrect. Your implementation is missing: ${missing.join(', ')}.`;
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete(exerciseId, false);
            }
        }


        // Evaluar arquitectura CNN diseñada
        function evaluateArchitecture(exerciseId) {
            const dropZone = document.getElementById('architecture-drop-zone');
            const items = dropZone.querySelectorAll('.drag-item');
            let feedbackElement = document.getElementById('feedback-' + exerciseId);
            
            if (items.length < 5) {
                feedbackElement.textContent = 'Your architecture is too simple. Add more layers to create a functional CNN.';
                feedbackElement.className = 'feedback incorrect';

                return;
            }
            
            // Verificar estructura básica
            const layers = Array.from(items).map(item => item.dataset.id);
            
            const hasInput = layers.includes('input');
            const hasConv = layers.filter(l => l.startsWith('conv')).length > 0;
            const hasPool = layers.filter(l => l.startsWith('pool')).length > 0;
            const hasFlatten = layers.includes('flatten');
            const hasDense = layers.filter(l => l.startsWith('dense')).length > 0;
            const hasOutput = layers.includes('dense2'); // Dense con softmax
            
            // Verificar orden correcto
            const inputFirst = layers[0] === 'input';
            const outputLast = layers[layers.length - 1] === 'dense2';
            const flattenBeforeDense = layers.indexOf('flatten') < layers.indexOf('dense1');
            
            if (hasInput && hasConv && hasPool && hasFlatten && hasDense && hasOutput &&
                inputFirst && outputLast && flattenBeforeDense) {
                feedbackElement.textContent = 'Excellent! You have designed a valid CNN architecture with the correct structure.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete(exerciseId, true);
            } else {
                let errors = [];
                if (!hasInput || !inputFirst) errors.push('The input layer must be first');
                if (!hasConv) errors.push('Missing convolutional layers');
                if (!hasPool) errors.push('Missing pooling layers');
                if (!hasFlatten) errors.push('Missing flatten layer');
                if (!hasDense) errors.push('Missing dense layers');
                if (!hasOutput || !outputLast) errors.push('The output layer must be the last one');
                if (hasFlatten && hasDense && !flattenBeforeDense) errors.push('The flatten layer must come before the dense layers');

                feedbackElement.textContent = `Your architecture has the following issues: ${errors.join('; ')}.`;
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete(exerciseId, false);
            }

        }
        
        // Check architecture use cases
        function checkArchitectureUseCase() {
            const correctAnswers = {
                'arch-use1': 1, // YOLO for real-time detection
                'arch-use2': 2, // U-Net for medical image segmentation
                'arch-use3': 0  // ResNet-50 for high-accuracy classification
            };

            let allCorrect = true;
            let feedback = '';

            for (const [id, correctIndex] of Object.entries(correctAnswers)) {
                if (selectedOptions[id] === undefined) {
                    feedback += `Please select an option for all use cases.\n`;
                    allCorrect = false;
                    break;
                }

                if (selectedOptions[id] !== correctIndex) {
                    allCorrect = false;
                }
            }

            let feedbackElement = document.getElementById('feedback-arch-use');

            if (allCorrect) {
                feedbackElement.textContent = 'Correct! You have selected the most appropriate architectures for each use case.';
                feedbackElement.className = 'feedback correct';
                markExerciseComplete('arch-use', true);
            } else if (feedback) {
                feedbackElement.textContent = feedback;
                feedbackElement.className = 'feedback incorrect';
            } else {
                feedbackElement.textContent = 'Incorrect. Review your selections considering the characteristics and requirements of each use case.';
                feedbackElement.className = 'feedback incorrect';
                markExerciseComplete('arch-use', false);
            }
        }

        
        // Mostrar pista
        function showHint(hintId) {
            const hint = document.getElementById(hintId);
            hint.classList.toggle('visible');
        }
        
        // Marcar ejercicio como completado
        function markExerciseComplete(exerciseId, isCorrect) {
            completedExercises[exerciseId] = isCorrect;
            
            if (isCorrect) {
                score += 1;
            }
            
            updateProgress();
            checkAllCompleted();
        }
        
        // Actualizar barra de progreso
        function updateProgress() {
            const completedCount = Object.values(completedExercises).filter(Boolean).length;
            const progressPercent = (completedCount / totalExercises) * 100;
            
            document.getElementById('progress-fill').style.width = `${progressPercent}%`;
            document.getElementById('progress-text').textContent = `${Math.round(progressPercent)}%`;
        }
        
        // Verificar si todos los ejercicios están completados
        function checkAllCompleted() {
            const completedCount = Object.keys(completedExercises).length;
            
            if (completedCount >= totalExercises) {
                showResults();
            }
        }
        
        // Mostrar resultados finales
        function showResults() {
            document.getElementById('result-summary').style.display = 'block';
            document.getElementById('final-score').textContent = score;
            document.getElementById('total-score').textContent = totalExercises;
            
            // Desplazar a los resultados
            document.getElementById('result-summary').scrollIntoView({ behavior: 'smooth' });
        }
        
        // Mostrar certificado
        function showCertificate() {
            // Solicitar nombre al usuario
            const userName = prompt('Introduce tu nombre para el certificado:', 'Estudiante');
            
            if (userName) {
                document.getElementById('user-name').textContent = userName;
                
                // Fecha actual
                const today = new Date();
                const dateString = today.toLocaleDateString('es-ES', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                document.getElementById('certificate-date').textContent = dateString;
                
                // Mostrar certificado
                document.getElementById('certificate').style.display = 'block';
                document.getElementById('certificate').scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Allow removing items from the architecture drop zone on click
        document.addEventListener('click', function (e) {
            const item = e.target;
            const dropZone = document.getElementById('architecture-drop-zone');

            if (item.classList.contains('drag-item') && item.closest('#architecture-drop-zone')) {
                dropZone.removeChild(item);

            }
            if (item.classList.contains('drag-item') && item.closest('.drop-zone')) {
                item.remove();
            }            
        });

    </script>
</body>
</html>
