[Translated Content]
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador Interactivo de Convolución</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            flex: 1;
            min-width: 300px;
        }
        .visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .canvas-container {
            text-align: center;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select, input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .filter-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        .filter-cell {
            width: 100%;
            text-align: center;
        }
        .explanation {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        #feature-map {
            height: 300px;
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background-color: #eee;
            border: none;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        .tab.active {
            background-color: #3498db;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .loading {
            text-align: center;
            padding: 20px;
            font-weight: bold;
            color: #3498db;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Visualizador Interactivo de Convolución</h1>
    
    <div id="error-message" class="error"></div>
    
    <div class="tabs">
        <button class="tab active" onclick="openTab(event, 'basic')">Convolución Básica</button>
        <button class="tab" onclick="openTab(event, 'advanced')">Características Avanzadas</button>
        <button class="tab" onclick="openTab(event, 'activation')">Funciones de Activación</button>
        <button class="tab" onclick="openTab(event, 'pooling')">Pooling</button>
    </div>

    <div id="basic" class="tab-content active">
        <div class="container">
            <div class="panel">
                <h2>Controles</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="image-select">Imagen de entrada:</label>
                        <select id="image-select" onchange="updateImage()">
                            <option value="random">Patrón aleatorio</option>
                            <option value="gradient">Gradiente</option>
                            <option value="checkerboard">Tablero de ajedrez</option>
                            <option value="circle">Círculo</option>
                            <option value="lines">Líneas</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="filter-select">Filtro predefinido:</label>
                        <select id="filter-select" onchange="updateFilter()">
                            <option value="edge-detection">Detección de bordes</option>
                            <option value="sharpen">Nitidez</option>
                            <option value="blur">Desenfoque</option>
                            <option value="emboss">Relieve</option>
                            <option value="custom">Personalizado</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Filtro personalizado:</label>
                        <div class="filter-grid">
                            <input type="number" class="filter-cell" value="0" min="-5" max="5" step="0.1" onchange="updateCustomFilter(0, 0, this.value)">
                            <input type="number" class="filter-cell" value="0" min="-5" max="5" step="0.1" onchange="updateCustomFilter(0, 1, this.value)">
                            <input type="number" class="filter-cell" value="0" min="-5" max="5" step="0.1" onchange="updateCustomFilter(0, 2, this.value)">
                            <input type="number" class="filter-cell" value="0" min="-5" max="5" step="0.1" onchange="updateCustomFilter(1, 0, this.value)">
                            <input type="number" class="filter-cell" value="1" min="-5" max="5" step="0.1" onchange="updateCustomFilter(1, 1, this.value)">
                            <input type="number" class="filter-cell" value="0" min="-5" max="5" step="0.1" onchange="updateCustomFilter(1, 2, this.value)">
                            <input type="number" class="filter-cell" value="0" min="-5" max="5" step="0.1" onchange="updateCustomFilter(2, 0, this.value)">
                            <input type="number" class="filter-cell" value="0" min="-5" max="5" step="0.1" onchange="updateCustomFilter(2, 1, this.value)">
                            <input type="number" class="filter-cell" value="0" min="-5" max="5" step="0.1" onchange="updateCustomFilter(2, 2, this.value)">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="stride-select">Stride:</label>
                        <select id="stride-select" onchange="updateConvolution()">
                            <option value="1">1 (Sin salto)</option>
                            <option value="2">2 (Salto de 2 píxeles)</option>
                            <option value="3">3 (Salto de 3 píxeles)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="padding-select">Padding:</label>
                        <select id="padding-select" onchange="updateConvolution()">
                            <option value="valid">Valid (Sin padding)</option>
                            <option value="same">Same (Preservar dimensiones)</option>
                        </select>
                    </div>
                    
                    <button onclick="applyConvolution()">Aplicar Convolución</button>
                </div>
                
                <div class="explanation">
                    <h3>¿Qué es la convolución?</h3>
                    <p>La convolución es una operación matemática fundamental en las CNN que consiste en deslizar un filtro (o kernel) sobre una imagen de entrada, realizando multiplicaciones elemento a elemento y sumando los resultados.</p>
                    <p>Esta operación permite a la red detectar características como bordes, texturas y patrones en la imagen.</p>
                    <p>Experimenta con diferentes filtros y parámetros para ver cómo afectan al resultado de la convolución.</p>
                </div>
            </div>
            
            <div class="panel">
                <h2>Visualización</h2>
                <div class="visualization">
                    <div class="canvas-container">
                        <h3>Imagen de Entrada</h3>
                        <div id="input-canvas"></div>
                    </div>
                    
                    <div class="canvas-container">
                        <h3>Mapa de Características</h3>
                        <div id="output-canvas"></div>
                    </div>
                </div>
                
                <div id="feature-map"></div>
                
                <div class="explanation">
                    <h3>Interpretación</h3>
                    <p>El mapa de características muestra el resultado de aplicar el filtro seleccionado a la imagen de entrada.</p>
                    <p>Las áreas más brillantes indican una alta activación del filtro, lo que significa que ha detectado un patrón similar a lo que el filtro está diseñado para encontrar.</p>
                    <p>La visualización 3D muestra la intensidad de las activaciones como altura, proporcionando una perspectiva adicional sobre cómo el filtro responde a diferentes partes de la imagen.</p>
                </div>
            </div>
        </div>
    </div>

    <div id="advanced" class="tab-content">
        <div class="container">
            <div class="panel">
                <h2>Características Avanzadas</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="channels-select">Canales de entrada:</label>
                        <select id="channels-select" onchange="updateChannels()">
                            <option value="1">1 (Escala de grises)</option>
                            <option value="3">3 (RGB)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="filters-count">Número de filtros:</label>
                        <select id="filters-count" onchange="updateFiltersCount()">
                            <option value="1">1 filtro</option>
                            <option value="2">2 filtros</option>
                            <option value="4">4 filtros</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="filter-size">Tamaño del filtro:</label>
                        <select id="filter-size" onchange="updateFilterSize()">
                            <option value="3">3x3</option>
                            <option value="5">5x5</option>
                            <option value="7">7x7</option>
                        </select>
                    </div>
                    
                    <button onclick="applyMultiChannelConvolution()">Aplicar Convolución Multicanal</button>
                </div>
                
                <div class="explanation">
                    <h3>Convolución Multicanal</h3>
                    <p>En las CNN reales, las imágenes suelen tener múltiples canales (RGB) y se aplican múltiples filtros para detectar diferentes características.</p>
                    <p>Cada filtro genera un mapa de características diferente, y estos mapas se combinan en capas posteriores para formar representaciones más complejas.</p>
                    <p>El tamaño del filtro afecta al campo receptivo: filtros más grandes pueden capturar patrones más amplios pero requieren más cómputo.</p>
                </div>
            </div>
            
            <div class="panel">
                <h2>Visualización Multicanal</h2>
                <div id="multichannel-visualization">
                    <div class="canvas-container">
                        <h3>Imagen RGB</h3>
                        <div id="rgb-input-canvas"></div>
                    </div>
                    <div id="feature-maps-container"></div>
                </div>
                
                <div class="explanation">
                    <h3>Interpretación</h3>
                    <p>Cada mapa de características muestra la respuesta de un filtro diferente aplicado a la imagen de entrada.</p>
                    <p>Observe cómo diferentes filtros detectan diferentes aspectos de la imagen, como bordes horizontales, verticales o texturas específicas.</p>
                    <p>En una CNN real, estos mapas de características servirían como entrada para la siguiente capa convolucional.</p>
                </div>
            </div>
        </div>
    </div>

    <div id="activation" class="tab-content">
        <div class="container">
            <div class="panel">
                <h2>Funciones de Activación</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="activation-function">Función de activación:</label>
                        <select id="activation-function" onchange="updateActivation()">
                            <option value="none">Sin activación</option>
                            <option value="relu">ReLU</option>
                            <option value="sigmoid">Sigmoid</option>
                            <option value="tanh">Tanh</option>
                            <option value="leaky_relu">Leaky ReLU</option>
                        </select>
                    </div>
                    
                    <div class="control-group" id="leaky-alpha-container" style="display: none;">
                        <label for="leaky-alpha">Alpha para Leaky ReLU:</label>
                        <input type="range" id="leaky-alpha" min="0.01" max="0.5" step="0.01" value="0.1" onchange="updateActivation()">
                        <span id="leaky-alpha-value">0.1</span>
                    </div>
                    
                    <button onclick="applyActivation()">Aplicar Activación</button>
                </div>
                
                <div class="explanation">
                    <h3>Funciones de Activación</h3>
                    <p>Las funciones de activación introducen no-linealidad en las redes neuronales, permitiéndoles aprender relaciones complejas.</p>
                    <p><strong>ReLU</strong> (Rectified Linear Unit): f(x) = max(0, x). Simple y eficiente, pero puede sufrir de "neuronas muertas".</p>
                    <p><strong>Sigmoid</strong>: f(x) = 1/(1+e^(-x)). Mapea valores a [0,1], pero sufre de desvanecimiento del gradiente.</p>
                    <p><strong>Tanh</strong>: f(x) = tanh(x). Similar a sigmoid pero con rango [-1,1].</p>
                    <p><strong>Leaky ReLU</strong>: f(x) = max(αx, x). Soluciona el problema de las neuronas muertas permitiendo pequeños gradientes negativos.</p>
                </div>
            </div>
            
            <div class="panel">
                <h2>Visualización de Activaciones</h2>
                <div class="visualization">
                    <div class="canvas-container">
                        <h3>Antes de Activación</h3>
                        <div id="pre-activation-canvas"></div>
                    </div>
                    
                    <div class="canvas-container">
                        <h3>Después de Activación</h3>
                        <div id="post-activation-canvas"></div>
                    </div>
                </div>
                
                <div id="activation-function-plot"></div>
                
                <div class="explanation">
                    <h3>Interpretación</h3>
                    <p>Observe cómo la función de activación transforma los valores del mapa de características.</p>
                    <p>ReLU elimina todos los valores negativos, mientras que Sigmoid comprime todos los valores al rango [0,1].</p>
                    <p>La gráfica muestra la función de activación aplicada, donde el eje X representa los valores de entrada y el eje Y los valores transformados.</p>
                </div>
            </div>
        </div>
    </div>

    <div id="pooling" class="tab-content">
        <div class="container">
            <div class="panel">
                <h2>Operaciones de Pooling</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="pooling-type">Tipo de pooling:</label>
                        <select id="pooling-type" onchange="updatePooling()">
                            <option value="max">Max Pooling</option>
                            <option value="avg">Average Pooling</option>
                            <option value="global_avg">Global Average Pooling</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="pool-size">Tamaño de ventana:</label>
                        <select id="pool-size" onchange="updatePooling()">
                            <option value="2">2x2</option>
                            <option value="3">3x3</option>
                            <option value="4">4x4</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="pool-stride">Stride:</label>
                        <select id="pool-stride" onchange="updatePooling()">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                        </select>
                    </div>
                    
                    <button onclick="applyPooling()">Aplicar Pooling</button>
                </div>
                
                <div class="explanation">
                    <h3>Operaciones de Pooling</h3>
                    <p>El pooling reduce la dimensionalidad espacial de los mapas de características, disminuyendo el costo computacional y proporcionando invariancia a pequeñas traslaciones.</p>
                    <p><strong>Max Pooling</strong>: Selecciona el valor máximo en cada ventana, preservando las características más prominentes.</p>
                    <p><strong>Average Pooling</strong>: Calcula el promedio de los valores en cada ventana, preservando información de fondo.</p>
                    <p><strong>Global Average Pooling</strong>: Calcula el promedio de todo el mapa de características, reduciendo cada mapa a un solo valor.</p>
                </div>
            </div>
            
            <div class="panel">
                <h2>Visualización de Pooling</h2>
                <div class="visualization">
                    <div class="canvas-container">
                        <h3>Antes de Pooling</h3>
                        <div id="pre-pooling-canvas"></div>
                    </div>
                    
                    <div class="canvas-container">
                        <h3>Después de Pooling</h3>
                        <div id="post-pooling-canvas"></div>
                    </div>
                </div>
                
                <div class="explanation">
                    <h3>Interpretación</h3>
                    <p>Observe cómo el pooling reduce la resolución espacial mientras intenta preservar la información importante.</p>
                    <p>Max Pooling tiende a preservar bordes y características destacadas, mientras que Average Pooling suaviza la imagen.</p>
                    <p>El stride controla cuánto se desplaza la ventana de pooling: un stride mayor resulta en una reducción más agresiva de la dimensionalidad.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let inputImage = [];
        let currentFilter = [];
        let outputImage = [];
        let stride = 1;
        let padding = 'valid';
        let imageSize = 28;
        let p5Instance = null;
        let librariesLoaded = {
            p5: false,
            plotly: false
        };
        let preActivationImage = [];
        let postActivationImage = [];
        let prePoolingImage = [];
        let postPoolingImage = [];
        let rgbInputImage = [];
        let featureMaps = [];
        
        // Filtros predefinidos
        const filters = {
            'edge-detection': [
                [-1, -1, -1],
                [-1,  8, -1],
                [-1, -1, -1]
            ],
            'sharpen': [
                [ 0, -1,  0],
                [-1,  5, -1],
                [ 0, -1,  0]
            ],
            'blur': [
                [1/9, 1/9, 1/9],
                [1/9, 1/9, 1/9],
                [1/9, 1/9, 1/9]
            ],
            'emboss': [
                [-2, -1,  0],
                [-1,  1,  1],
                [ 0,  1,  2]
            ],
            'custom': [
                [0, 0, 0],
                [0, 1, 0],
                [0, 0, 0]
            ]
        };

        // Verificar carga de bibliotecas
        function checkLibraries() {
            if (typeof p5 !== 'undefined') {
                librariesLoaded.p5 = true;
            }
            
            if (typeof Plotly !== 'undefined') {
                librariesLoaded.plotly = true;
            }
            
            if (librariesLoaded.p5 && librariesLoaded.plotly) {
                initializeApp();
            } else {
                showError("Error: No se pudieron cargar todas las bibliotecas necesarias. Por favor, recarga la página.");
            }
        }
        
        // Mostrar mensaje de error
        function showError(message) {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }
        
        // Inicializar aplicación
        function initializeApp() {
            // Crear nueva instancia de p5
            p5Instance = new p5(function(p) {
                p.setup = function() {
                    // Crear canvas para imagen de entrada
                    let inputCanvas = p.createCanvas(280, 280);
                    inputCanvas.parent('input-canvas');
                    
                    // Crear canvas para imagen de salida
                    let outputCanvas = p.createCanvas(280, 280);
                    outputCanvas.parent('output-canvas');
                    
                    // Crear canvas para activación
                    let preActivationCanvas = p.createCanvas(280, 280);
                    preActivationCanvas.parent('pre-activation-canvas');
                    
                    let postActivationCanvas = p.createCanvas(280, 280);
                    postActivationCanvas.parent('post-activation-canvas');
                    
                    // Crear canvas para pooling
                    let prePoolingCanvas = p.createCanvas(280, 280);
                    prePoolingCanvas.parent('pre-pooling-canvas');
                    
                    let postPoolingCanvas = p.createCanvas(280, 280);
                    postPoolingCanvas.parent('post-pooling-canvas');
                    
                    // Crear canvas para RGB
                    let rgbCanvas = p.createCanvas(280, 280);
                    rgbCanvas.parent('rgb-input-canvas');
                    
                    // Inicializar imagen de entrada con patrón aleatorio
                    createRandomImage();
                    
                    // Inicializar filtro con detección de bordes
                    currentFilter = JSON.parse(JSON.stringify(filters['edge-detection']));
                    updateFilterInputs();
                    
                    // Aplicar convolución inicial
                    applyConvolution();
                };
                
                p.draw = function() {
                    // No necesitamos actualización continua
                };
            });
        }
        
        // Crear imagen de entrada aleatoria
        function createRandomImage() {
            inputImage = [];
            for (let i = 0; i < imageSize; i++) {
                inputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    inputImage[i][j] = Math.random();
                }
            }
            drawInputImage();
            
            // Copiar para otras pestañas
            preActivationImage = JSON.parse(JSON.stringify(inputImage));
            prePoolingImage = JSON.parse(JSON.stringify(inputImage));
            
            // Crear imagen RGB para pestaña avanzada
            createRGBImage();
        }
        
        // Crear imagen RGB
        function createRGBImage() {
            rgbInputImage = [];
            for (let i = 0; i < imageSize; i++) {
                rgbInputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    rgbInputImage[i][j] = {
                        r: Math.random(),
                        g: Math.random(),
                        b: Math.random()
                    };
                }
            }
            drawRGBImage();
        }
        
        // Crear imagen de gradiente
        function createGradientImage() {
            inputImage = [];
            for (let i = 0; i < imageSize; i++) {
                inputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    inputImage[i][j] = i / imageSize;
                }
            }
            drawInputImage();
            
            // Copiar para otras pestañas
            preActivationImage = JSON.parse(JSON.stringify(inputImage));
            prePoolingImage = JSON.parse(JSON.stringify(inputImage));
            
            // Crear imagen RGB para pestaña avanzada
            rgbInputImage = [];
            for (let i = 0; i < imageSize; i++) {
                rgbInputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    rgbInputImage[i][j] = {
                        r: i / imageSize,
                        g: j / imageSize,
                        b: (i + j) / (2 * imageSize)
                    };
                }
            }
            drawRGBImage();
        }
        
        // Crear imagen de tablero de ajedrez
        function createCheckerboardImage() {
            inputImage = [];
            for (let i = 0; i < imageSize; i++) {
                inputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    inputImage[i][j] = (i % 4 < 2) ^ (j % 4 < 2) ? 1 : 0;
                }
            }
            drawInputImage();
            
            // Copiar para otras pestañas
            preActivationImage = JSON.parse(JSON.stringify(inputImage));
            prePoolingImage = JSON.parse(JSON.stringify(inputImage));
            
            // Crear imagen RGB para pestaña avanzada
            rgbInputImage = [];
            for (let i = 0; i < imageSize; i++) {
                rgbInputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    const val = (i % 4 < 2) ^ (j % 4 < 2) ? 1 : 0;
                    rgbInputImage[i][j] = {
                        r: val,
                        g: 1 - val,
                        b: (i % 8 < 4) ? val : 1 - val
                    };
                }
            }
            drawRGBImage();
        }
        
        // Crear imagen de círculo
        function createCircleImage() {
            inputImage = [];
            let center = imageSize / 2;
            let radius = imageSize / 3;
            for (let i = 0; i < imageSize; i++) {
                inputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    let dist = Math.sqrt((i - center) ** 2 + (j - center) ** 2);
                    inputImage[i][j] = dist < radius ? 1 : 0;
                }
            }
            drawInputImage();
            
            // Copiar para otras pestañas
            preActivationImage = JSON.parse(JSON.stringify(inputImage));
            prePoolingImage = JSON.parse(JSON.stringify(inputImage));
            
            // Crear imagen RGB para pestaña avanzada
            rgbInputImage = [];
            for (let i = 0; i < imageSize; i++) {
                rgbInputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    let dist = Math.sqrt((i - center) ** 2 + (j - center) ** 2);
                    let val = dist < radius ? 1 : 0;
                    let angle = Math.atan2(i - center, j - center) / (2 * Math.PI) + 0.5; // 0 to 1
                    
                    rgbInputImage[i][j] = {
                        r: val * (1 - angle),
                        g: val * angle,
                        b: val * (dist / radius)
                    };
                }
            }
            drawRGBImage();
        }
        
        // Crear imagen de líneas
        function createLinesImage() {
            inputImage = [];
            for (let i = 0; i < imageSize; i++) {
                inputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    inputImage[i][j] = (i % 4 === 0 || j % 4 === 0) ? 1 : 0;
                }
            }
            drawInputImage();
            
            // Copiar para otras pestañas
            preActivationImage = JSON.parse(JSON.stringify(inputImage));
            prePoolingImage = JSON.parse(JSON.stringify(inputImage));
            
            // Crear imagen RGB para pestaña avanzada
            rgbInputImage = [];
            for (let i = 0; i < imageSize; i++) {
                rgbInputImage[i] = [];
                for (let j = 0; j < imageSize; j++) {
                    rgbInputImage[i][j] = {
                        r: (i % 4 === 0) ? 1 : 0,
                        g: (j % 4 === 0) ? 1 : 0,
                        b: ((i + j) % 8 === 0) ? 1 : 0
                    };
                }
            }
            drawRGBImage();
        }
        
        // Dibujar imagen de entrada
        function drawInputImage() {
            try {
                const canvas = document.querySelector('#input-canvas canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const cellSize = canvas.width / imageSize;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const value = inputImage[i][j];
                        const color = Math.floor(value * 255);
                        ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            } catch (error) {
                console.error("Error al dibujar imagen de entrada:", error);
                showError("Error al dibujar imagen de entrada. Consulta la consola para más detalles.");
            }
        }
        
        // Dibujar imagen RGB
        function drawRGBImage() {
            try {
                const canvas = document.querySelector('#rgb-input-canvas canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const cellSize = canvas.width / imageSize;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const pixel = rgbInputImage[i][j];
                        const r = Math.floor(pixel.r * 255);
                        const g = Math.floor(pixel.g * 255);
                        const b = Math.floor(pixel.b * 255);
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            } catch (error) {
                console.error("Error al dibujar imagen RGB:", error);
                showError("Error al dibujar imagen RGB. Consulta la consola para más detalles.");
            }
        }
        
        // Dibujar imagen de salida
        function drawOutputImage() {
            try {
                const canvas = document.querySelector('#output-canvas canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const outputSize = outputImage.length;
                const cellSize = canvas.width / outputSize;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Encontrar valores mínimo y máximo para normalización
                let min = Infinity;
                let max = -Infinity;
                for (let i = 0; i < outputSize; i++) {
                    for (let j = 0; j < outputSize; j++) {
                        min = Math.min(min, outputImage[i][j]);
                        max = Math.max(max, outputImage[i][j]);
                    }
                }
                
                // Normalizar y dibujar
                const range = max - min;
                for (let i = 0; i < outputSize; i++) {
                    for (let j = 0; j < outputSize; j++) {
                        const normalizedValue = range === 0 ? 0.5 : (outputImage[i][j] - min) / range;
                        const color = Math.floor(normalizedValue * 255);
                        ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
                
                // Actualizar visualización 3D
                updateFeatureMapPlot();
            } catch (error) {
                console.error("Error al dibujar imagen de salida:", error);
                showError("Error al dibujar imagen de salida. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar visualización 3D del mapa de características
        function updateFeatureMapPlot() {
            try {
                if (!librariesLoaded.plotly) return;
                
                const outputSize = outputImage.length;
                
                // Preparar datos para Plotly
                const z = [];
                for (let i = 0; i < outputSize; i++) {
                    z.push([...outputImage[i]]);
                }
                
                // Crear gráfico 3D
                const data = [{
                    z: z,
                    type: 'surface',
                    colorscale: 'Viridis'
                }];
                
                const layout = {
                    title: 'Visualización 3D del Mapa de Características',
                    autosize: true,
                    margin: {
                        l: 65,
                        r: 50,
                        b: 65,
                        t: 90,
                    }
                };
                
                Plotly.newPlot('feature-map', data, layout);
            } catch (error) {
                console.error("Error al actualizar gráfico 3D:", error);
                showError("Error al actualizar gráfico 3D. Consulta la consola para más detalles.");
            }
        }
        
        // Aplicar convolución
        function applyConvolution() {
            try {
                stride = parseInt(document.getElementById('stride-select').value);
                padding = document.getElementById('padding-select').value;
                
                // Calcular tamaño de salida
                const filterSize = currentFilter.length;
                let outputSize;
                
                if (padding === 'valid') {
                    outputSize = Math.floor((imageSize - filterSize) / stride) + 1;
                } else { // 'same'
                    outputSize = Math.ceil(imageSize / stride);
                }
                
                // Inicializar imagen de salida
                outputImage = [];
                for (let i = 0; i < outputSize; i++) {
                    outputImage[i] = [];
                    for (let j = 0; j < outputSize; j++) {
                        outputImage[i][j] = 0;
                    }
                }
                
                // Aplicar convolución
                for (let i = 0; i < outputSize; i++) {
                    for (let j = 0; j < outputSize; j++) {
                        let sum = 0;
                        
                        // Calcular posición central en la imagen de entrada
                        let centerI, centerJ;
                        
                        if (padding === 'valid') {
                            centerI = i * stride;
                            centerJ = j * stride;
                        } else { // 'same'
                            const paddingSize = Math.floor(filterSize / 2);
                            centerI = i * stride - paddingSize;
                            centerJ = j * stride - paddingSize;
                        }
                        
                        // Aplicar filtro
                        for (let fi = 0; fi < filterSize; fi++) {
                            for (let fj = 0; fj < filterSize; fj++) {
                                const ii = centerI + fi;
                                const jj = centerJ + fj;
                                
                                // Verificar si está dentro de los límites
                                if (ii >= 0 && ii < imageSize && jj >= 0 && jj < imageSize) {
                                    sum += inputImage[ii][jj] * currentFilter[fi][fj];
                                }
                            }
                        }
                        
                        outputImage[i][j] = sum;
                    }
                }
                
                drawOutputImage();
                
                // Actualizar imágenes para otras pestañas
                preActivationImage = JSON.parse(JSON.stringify(outputImage));
                drawPreActivationImage();
                
                prePoolingImage = JSON.parse(JSON.stringify(outputImage));
                drawPrePoolingImage();
            } catch (error) {
                console.error("Error al aplicar convolución:", error);
                showError("Error al aplicar convolución. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar imagen de entrada
        function updateImage() {
            try {
                const imageType = document.getElementById('image-select').value;
                
                switch (imageType) {
                    case 'random':
                        createRandomImage();
                        break;
                    case 'gradient':
                        createGradientImage();
                        break;
                    case 'checkerboard':
                        createCheckerboardImage();
                        break;
                    case 'circle':
                        createCircleImage();
                        break;
                    case 'lines':
                        createLinesImage();
                        break;
                }
                
                applyConvolution();
            } catch (error) {
                console.error("Error al actualizar imagen:", error);
                showError("Error al actualizar imagen. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar filtro
        function updateFilter() {
            try {
                const filterType = document.getElementById('filter-select').value;
                currentFilter = JSON.parse(JSON.stringify(filters[filterType]));
                updateFilterInputs();
                applyConvolution();
            } catch (error) {
                console.error("Error al actualizar filtro:", error);
                showError("Error al actualizar filtro. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar filtro personalizado
        function updateCustomFilter(row, col, value) {
            try {
                if (document.getElementById('filter-select').value !== 'custom') {
                    document.getElementById('filter-select').value = 'custom';
                }
                
                currentFilter[row][col] = parseFloat(value);
                applyConvolution();
            } catch (error) {
                console.error("Error al actualizar filtro personalizado:", error);
                showError("Error al actualizar filtro personalizado. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar inputs del filtro
        function updateFilterInputs() {
            try {
                const filterCells = document.querySelectorAll('.filter-cell');
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        filterCells[i * 3 + j].value = currentFilter[i][j];
                    }
                }
            } catch (error) {
                console.error("Error al actualizar inputs del filtro:", error);
                showError("Error al actualizar inputs del filtro. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar convolución
        function updateConvolution() {
            applyConvolution();
        }
        
        // Cambiar de pestaña
        function openTab(evt, tabName) {
            try {
                // Ocultar todos los contenidos de pestañas
                const tabContents = document.getElementsByClassName('tab-content');
                for (let i = 0; i < tabContents.length; i++) {
                    tabContents[i].classList.remove('active');
                }
                
                // Desactivar todos los botones de pestañas
                const tabs = document.getElementsByClassName('tab');
                for (let i = 0; i < tabs.length; i++) {
                    tabs[i].classList.remove('active');
                }
                
                // Mostrar el contenido de la pestaña actual y activar el botón
                document.getElementById(tabName).classList.add('active');
                evt.currentTarget.classList.add('active');
                
                // Inicializar contenido específico de la pestaña si es necesario
                if (tabName === 'advanced' && !document.querySelector('#feature-maps-container canvas')) {
                    initializeAdvancedTab();
                } else if (tabName === 'activation' && !document.querySelector('#activation-function-plot .plotly')) {
                    initializeActivationTab();
                } else if (tabName === 'pooling' && !document.querySelector('#post-pooling-canvas canvas')) {
                    initializePoolingTab();
                }
            } catch (error) {
                console.error("Error al cambiar de pestaña:", error);
                showError("Error al cambiar de pestaña. Consulta la consola para más detalles.");
            }
        }
        
        // Inicializar pestaña avanzada
        function initializeAdvancedTab() {
            try {
                // Crear contenedores para mapas de características
                const container = document.getElementById('feature-maps-container');
                container.innerHTML = '';
                
                const filtersCount = parseInt(document.getElementById('filters-count').value);
                
                for (let i = 0; i < filtersCount; i++) {
                    const mapContainer = document.createElement('div');
                    mapContainer.className = 'canvas-container';
                    mapContainer.innerHTML = `<h3>Filtro ${i+1}</h3><div id="feature-map-${i}"></div>`;
                    container.appendChild(mapContainer);
                    
                    // Crear canvas para cada mapa
                    const canvas = document.createElement('canvas');
                    canvas.width = 280;
                    canvas.height = 280;
                    document.getElementById(`feature-map-${i}`).appendChild(canvas);
                }
                
                // Aplicar convolución multicanal inicial
                applyMultiChannelConvolution();
            } catch (error) {
                console.error("Error al inicializar pestaña avanzada:", error);
                showError("Error al inicializar pestaña avanzada. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar canales
        function updateChannels() {
            applyMultiChannelConvolution();
        }
        
        // Actualizar número de filtros
        function updateFiltersCount() {
            initializeAdvancedTab();
        }
        
        // Actualizar tamaño del filtro
        function updateFilterSize() {
            applyMultiChannelConvolution();
        }
        
        // Aplicar convolución multicanal
        function applyMultiChannelConvolution() {
            try {
                const channels = parseInt(document.getElementById('channels-select').value);
                const filtersCount = parseInt(document.getElementById('filters-count').value);
                const filterSize = parseInt(document.getElementById('filter-size').value);
                
                // Generar filtros aleatorios
                const multiFilters = [];
                for (let f = 0; f < filtersCount; f++) {
                    const filter = [];
                    for (let c = 0; c < channels; c++) {
                        const channelFilter = [];
                        for (let i = 0; i < filterSize; i++) {
                            const row = [];
                            for (let j = 0; j < filterSize; j++) {
                                row.push((Math.random() * 2 - 1) * 0.5);
                            }
                            channelFilter.push(row);
                        }
                        filter.push(channelFilter);
                    }
                    multiFilters.push(filter);
                }
                
                // Aplicar convolución para cada filtro
                featureMaps = [];
                for (let f = 0; f < filtersCount; f++) {
                    const outputSize = imageSize - filterSize + 1;
                    const featureMap = Array(outputSize).fill().map(() => Array(outputSize).fill(0));
                    
                    // Aplicar convolución
                    for (let i = 0; i < outputSize; i++) {
                        for (let j = 0; j < outputSize; j++) {
                            let sum = 0;
                            
                            // Para cada canal
                            for (let c = 0; c < channels; c++) {
                                // Aplicar filtro
                                for (let fi = 0; fi < filterSize; fi++) {
                                    for (let fj = 0; fj < filterSize; fj++) {
                                        const ii = i + fi;
                                        const jj = j + fj;
                                        
                                        if (channels === 1) {
                                            sum += inputImage[ii][jj] * multiFilters[f][c][fi][fj];
                                        } else {
                                            const pixel = rgbInputImage[ii][jj];
                                            const channelValue = c === 0 ? pixel.r : (c === 1 ? pixel.g : pixel.b);
                                            sum += channelValue * multiFilters[f][c][fi][fj];
                                        }
                                    }
                                }
                            }
                            
                            featureMap[i][j] = sum;
                        }
                    }
                    
                    featureMaps.push(featureMap);
                }
                
                // Dibujar mapas de características
                for (let f = 0; f < filtersCount; f++) {
                    drawFeatureMap(f);
                }
            } catch (error) {
                console.error("Error al aplicar convolución multicanal:", error);
                showError("Error al aplicar convolución multicanal. Consulta la consola para más detalles.");
            }
        }
        
        // Dibujar mapa de características
        function drawFeatureMap(index) {
            try {
                const canvas = document.querySelector(`#feature-map-${index} canvas`);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const featureMap = featureMaps[index];
                const mapSize = featureMap.length;
                const cellSize = canvas.width / mapSize;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Encontrar valores mínimo y máximo para normalización
                let min = Infinity;
                let max = -Infinity;
                for (let i = 0; i < mapSize; i++) {
                    for (let j = 0; j < mapSize; j++) {
                        min = Math.min(min, featureMap[i][j]);
                        max = Math.max(max, featureMap[i][j]);
                    }
                }
                
                // Normalizar y dibujar
                const range = max - min;
                for (let i = 0; i < mapSize; i++) {
                    for (let j = 0; j < mapSize; j++) {
                        const normalizedValue = range === 0 ? 0.5 : (featureMap[i][j] - min) / range;
                        const color = Math.floor(normalizedValue * 255);
                        ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            } catch (error) {
                console.error(`Error al dibujar mapa de características ${index}:`, error);
                showError(`Error al dibujar mapa de características. Consulta la consola para más detalles.`);
            }
        }
        
        // Inicializar pestaña de activación
        function initializeActivationTab() {
            try {
                // Dibujar imagen pre-activación
                drawPreActivationImage();
                
                // Aplicar activación inicial
                applyActivation();
                
                // Dibujar gráfico de función de activación
                updateActivationFunctionPlot('none');
            } catch (error) {
                console.error("Error al inicializar pestaña de activación:", error);
                showError("Error al inicializar pestaña de activación. Consulta la consola para más detalles.");
            }
        }
        
        // Dibujar imagen pre-activación
        function drawPreActivationImage() {
            try {
                const canvas = document.querySelector('#pre-activation-canvas canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const imageSize = preActivationImage.length;
                const cellSize = canvas.width / imageSize;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Encontrar valores mínimo y máximo para normalización
                let min = Infinity;
                let max = -Infinity;
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        min = Math.min(min, preActivationImage[i][j]);
                        max = Math.max(max, preActivationImage[i][j]);
                    }
                }
                
                // Normalizar y dibujar
                const range = max - min;
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const normalizedValue = range === 0 ? 0.5 : (preActivationImage[i][j] - min) / range;
                        const color = Math.floor(normalizedValue * 255);
                        ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            } catch (error) {
                console.error("Error al dibujar imagen pre-activación:", error);
                showError("Error al dibujar imagen pre-activación. Consulta la consola para más detalles.");
            }
        }
        
        // Dibujar imagen post-activación
        function drawPostActivationImage() {
            try {
                const canvas = document.querySelector('#post-activation-canvas canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const imageSize = postActivationImage.length;
                const cellSize = canvas.width / imageSize;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Encontrar valores mínimo y máximo para normalización
                let min = Infinity;
                let max = -Infinity;
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        min = Math.min(min, postActivationImage[i][j]);
                        max = Math.max(max, postActivationImage[i][j]);
                    }
                }
                
                // Normalizar y dibujar
                const range = max - min;
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const normalizedValue = range === 0 ? 0.5 : (postActivationImage[i][j] - min) / range;
                        const color = Math.floor(normalizedValue * 255);
                        ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            } catch (error) {
                console.error("Error al dibujar imagen post-activación:", error);
                showError("Error al dibujar imagen post-activación. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar función de activación
        function updateActivation() {
            try {
                const activationType = document.getElementById('activation-function').value;
                
                // Mostrar/ocultar control de alpha para Leaky ReLU
                const leakyAlphaContainer = document.getElementById('leaky-alpha-container');
                leakyAlphaContainer.style.display = activationType === 'leaky_relu' ? 'block' : 'none';
                
                // Actualizar valor mostrado de alpha
                if (activationType === 'leaky_relu') {
                    const alpha = document.getElementById('leaky-alpha').value;
                    document.getElementById('leaky-alpha-value').textContent = alpha;
                }
                
                // Actualizar gráfico de función de activación
                updateActivationFunctionPlot(activationType);
                
                // Aplicar activación
                applyActivation();
            } catch (error) {
                console.error("Error al actualizar activación:", error);
                showError("Error al actualizar activación. Consulta la consola para más detalles.");
            }
        }
        
        // Aplicar función de activación
        function applyActivation() {
            try {
                const activationType = document.getElementById('activation-function').value;
                const alpha = parseFloat(document.getElementById('leaky-alpha').value);
                
                // Copiar imagen pre-activación
                const imageSize = preActivationImage.length;
                postActivationImage = [];
                for (let i = 0; i < imageSize; i++) {
                    postActivationImage[i] = [];
                    for (let j = 0; j < imageSize; j++) {
                        const value = preActivationImage[i][j];
                        
                        // Aplicar función de activación
                        switch (activationType) {
                            case 'none':
                                postActivationImage[i][j] = value;
                                break;
                            case 'relu':
                                postActivationImage[i][j] = Math.max(0, value);
                                break;
                            case 'sigmoid':
                                postActivationImage[i][j] = 1 / (1 + Math.exp(-value));
                                break;
                            case 'tanh':
                                postActivationImage[i][j] = Math.tanh(value);
                                break;
                            case 'leaky_relu':
                                postActivationImage[i][j] = value > 0 ? value : alpha * value;
                                break;
                            default:
                                postActivationImage[i][j] = value;
                        }
                    }
                }
                
                drawPostActivationImage();
            } catch (error) {
                console.error("Error al aplicar activación:", error);
                showError("Error al aplicar activación. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar gráfico de función de activación
        function updateActivationFunctionPlot(activationType) {
            try {
                if (!librariesLoaded.plotly) return;
                
                // Generar datos para la gráfica
                const x = [];
                const y = [];
                const alpha = parseFloat(document.getElementById('leaky-alpha').value);
                
                for (let i = -5; i <= 5; i += 0.1) {
                    x.push(i);
                    
                    switch (activationType) {
                        case 'none':
                            y.push(i);
                            break;
                        case 'relu':
                            y.push(Math.max(0, i));
                            break;
                        case 'sigmoid':
                            y.push(1 / (1 + Math.exp(-i)));
                            break;
                        case 'tanh':
                            y.push(Math.tanh(i));
                            break;
                        case 'leaky_relu':
                            y.push(i > 0 ? i : alpha * i);
                            break;
                        default:
                            y.push(i);
                    }
                }
                
                // Crear gráfico
                const data = [{
                    x: x,
                    y: y,
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        color: '#3498db',
                        width: 3
                    }
                }];
                
                const layout = {
                    title: `Función de Activación: ${activationType === 'none' ? 'Lineal' : activationType}`,
                    xaxis: {
                        title: 'Entrada',
                        zeroline: true,
                        zerolinecolor: '#999',
                        zerolinewidth: 1
                    },
                    yaxis: {
                        title: 'Salida',
                        zeroline: true,
                        zerolinecolor: '#999',
                        zerolinewidth: 1
                    },
                    margin: {
                        l: 50,
                        r: 50,
                        b: 50,
                        t: 50,
                        pad: 4
                    }
                };
                
                Plotly.newPlot('activation-function-plot', data, layout);
            } catch (error) {
                console.error("Error al actualizar gráfico de función de activación:", error);
                showError("Error al actualizar gráfico de función de activación. Consulta la consola para más detalles.");
            }
        }
        
        // Inicializar pestaña de pooling
        function initializePoolingTab() {
            try {
                // Dibujar imagen pre-pooling
                drawPrePoolingImage();
                
                // Aplicar pooling inicial
                applyPooling();
            } catch (error) {
                console.error("Error al inicializar pestaña de pooling:", error);
                showError("Error al inicializar pestaña de pooling. Consulta la consola para más detalles.");
            }
        }
        
        // Dibujar imagen pre-pooling
        function drawPrePoolingImage() {
            try {
                const canvas = document.querySelector('#pre-pooling-canvas canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const imageSize = prePoolingImage.length;
                const cellSize = canvas.width / imageSize;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Encontrar valores mínimo y máximo para normalización
                let min = Infinity;
                let max = -Infinity;
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        min = Math.min(min, prePoolingImage[i][j]);
                        max = Math.max(max, prePoolingImage[i][j]);
                    }
                }
                
                // Normalizar y dibujar
                const range = max - min;
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const normalizedValue = range === 0 ? 0.5 : (prePoolingImage[i][j] - min) / range;
                        const color = Math.floor(normalizedValue * 255);
                        ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            } catch (error) {
                console.error("Error al dibujar imagen pre-pooling:", error);
                showError("Error al dibujar imagen pre-pooling. Consulta la consola para más detalles.");
            }
        }
        
        // Dibujar imagen post-pooling
        function drawPostPoolingImage() {
            try {
                const canvas = document.querySelector('#post-pooling-canvas canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const imageSize = postPoolingImage.length;
                const cellSize = canvas.width / imageSize;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Encontrar valores mínimo y máximo para normalización
                let min = Infinity;
                let max = -Infinity;
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        min = Math.min(min, postPoolingImage[i][j]);
                        max = Math.max(max, postPoolingImage[i][j]);
                    }
                }
                
                // Normalizar y dibujar
                const range = max - min;
                for (let i = 0; i < imageSize; i++) {
                    for (let j = 0; j < imageSize; j++) {
                        const normalizedValue = range === 0 ? 0.5 : (postPoolingImage[i][j] - min) / range;
                        const color = Math.floor(normalizedValue * 255);
                        ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            } catch (error) {
                console.error("Error al dibujar imagen post-pooling:", error);
                showError("Error al dibujar imagen post-pooling. Consulta la consola para más detalles.");
            }
        }
        
        // Actualizar parámetros de pooling
        function updatePooling() {
            applyPooling();
        }
        
        // Aplicar operación de pooling
        function applyPooling() {
            try {
                const poolingType = document.getElementById('pooling-type').value;
                const poolSize = parseInt(document.getElementById('pool-size').value);
                const poolStride = parseInt(document.getElementById('pool-stride').value);
                
                const inputSize = prePoolingImage.length;
                const outputSize = Math.floor((inputSize - poolSize) / poolStride) + 1;
                
                // Inicializar imagen post-pooling
                postPoolingImage = [];
                for (let i = 0; i < outputSize; i++) {
                    postPoolingImage[i] = [];
                    for (let j = 0; j < outputSize; j++) {
                        postPoolingImage[i][j] = 0;
                    }
                }
                
                // Aplicar pooling
                if (poolingType === 'global_avg') {
                    // Global Average Pooling
                    let sum = 0;
                    for (let i = 0; i < inputSize; i++) {
                        for (let j = 0; j < inputSize; j++) {
                            sum += prePoolingImage[i][j];
                        }
                    }
                    const avg = sum / (inputSize * inputSize);
                    
                    // Llenar toda la imagen con el mismo valor
                    for (let i = 0; i < outputSize; i++) {
                        for (let j = 0; j < outputSize; j++) {
                            postPoolingImage[i][j] = avg;
                        }
                    }
                } else {
                    // Max o Average Pooling
                    for (let i = 0; i < outputSize; i++) {
                        for (let j = 0; j < outputSize; j++) {
                            const startI = i * poolStride;
                            const startJ = j * poolStride;
                            
                            if (poolingType === 'max') {
                                // Max Pooling
                                let maxVal = -Infinity;
                                for (let pi = 0; pi < poolSize; pi++) {
                                    for (let pj = 0; pj < poolSize; pj++) {
                                        const ii = startI + pi;
                                        const jj = startJ + pj;
                                        
                                        if (ii < inputSize && jj < inputSize) {
                                            maxVal = Math.max(maxVal, prePoolingImage[ii][jj]);
                                        }
                                    }
                                }
                                postPoolingImage[i][j] = maxVal;
                            } else {
                                // Average Pooling
                                let sum = 0;
                                let count = 0;
                                for (let pi = 0; pi < poolSize; pi++) {
                                    for (let pj = 0; pj < poolSize; pj++) {
                                        const ii = startI + pi;
                                        const jj = startJ + pj;
                                        
                                        if (ii < inputSize && jj < inputSize) {
                                            sum += prePoolingImage[ii][jj];
                                            count++;
                                        }
                                    }
                                }
                                postPoolingImage[i][j] = count > 0 ? sum / count : 0;
                            }
                        }
                    }
                }
                
                drawPostPoolingImage();
            } catch (error) {
                console.error("Error al aplicar pooling:", error);
                showError("Error al aplicar pooling. Consulta la consola para más detalles.");
            }
        }
        
        // Iniciar la aplicación cuando se cargue la página
        window.onload = function() {
            checkLibraries();
        };
    </script>
</body>
</html>
